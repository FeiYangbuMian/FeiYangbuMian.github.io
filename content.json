{"meta":{"title":"FeiYangbuMian","subtitle":null,"description":null,"author":"FeiYangbuMian","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Vue2项目实战总结二","slug":"live/sum-report","date":"2019-10-07T06:07:01.000Z","updated":"2019-10-07T07:34:55.012Z","comments":true,"path":"2019/10/07/live/sum-report/","link":"","permalink":"http://yoursite.com/2019/10/07/live/sum-report/","excerpt":"","text":"项目工程化封装axios使用store动态路由与动态侧栏","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue2项目实战总结一","slug":"live/sum-marathon","date":"2019-08-31T06:50:01.000Z","updated":"2019-10-07T08:26:29.314Z","comments":true,"path":"2019/08/31/live/sum-marathon/","link":"","permalink":"http://yoursite.com/2019/08/31/live/sum-marathon/","excerpt":"","text":"最近遇见的问题与解决方案axiosvue2之axios 因为本项目用的是json格式，所以未使用插件qs 安装 1npm install axios main.js中引入 12import Axios from &apos;axios&apos;Vue.prototype.$axios = Axios; //在Vue的原型上添加$axios方法 main.js中配置 12345678910111213141516171819202122232425// 设置baseURLAxios.defaults.baseURL = &apos;http://192.168.20.56:8089&apos;// 设置token值// Axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN// 请求头Axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/json;charset=UTF-8&apos;// 添加请求拦截器Axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 console.log(config) return config&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error)&#125;)// 添加响应拦截器Axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response&#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error)&#125;) 页面中使用 123456789101112131415161718// postthis.$axios.post(&apos;/insertNews&apos;, JSON.stringify(news)) .then(rsp =&gt; &#123; console.log(&apos;insertNews success&apos;) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;)// getthis.$axios.get(&apos;/selectnews&apos;, &#123; params: &#123; &apos;newsType&apos;: &apos;1&apos; &#125;&#125;).then(rsp =&gt; &#123; _this.tableData = rsp.data.list console.log(JSON.stringify(rsp.data))&#125;).catch(error =&gt; &#123; console.log(error) &#125;) wangEditorwangEditor官方文档 vue2+wangeditor牛刀小试 1npm install wangeditor 新增富文本组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;template&gt; &lt;div id=&quot;wangeditor&quot;&gt; &lt;div ref=&quot;editorElem&quot; style=&quot;text-align:left;width: 600px&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import WE from &apos;wangeditor&apos;export default &#123; name: &apos;WangEditor&apos;, data () &#123; return &#123; editor: null, editorContent: &apos;&apos; &#125; &#125;, // catchData是一个类似回调函数，来自父组件，当然也可以自己写一个函数，主要是用来获取富文本编辑器中的html内容用来传递给服务端 // content接收初始化数据 props: [&apos;catchData&apos;, &apos;content&apos;], // 接收父组件的方法 watch: &#123; content () &#123; this.editor.txt.html(this.content) &#125; &#125;, mounted () &#123; this.editor = new WE(this.$refs.editorElem) // 编辑器的事件，每次改变会获取其html内容 this.editor.customConfig.onchange = html =&gt; &#123; this.editorContent = html this.catchData(this.editorContent) // 把这个html通过catchData的方法传入父组件 &#125; this.editor.customConfig.zIndex = 2 // 修改编辑器的z-index this.editor.customConfig.pasteFilterStyle = false // 关闭粘贴样式的过滤 this.editor.customConfig.pasteIgnoreImg = true // 粘贴时忽视图片 // 自定义处理粘贴的文本内容 this.editor.customConfig.pasteTextHandle = function (content) &#123; // content 即粘贴过来的内容（html 或 纯文本），可进行自定义处理然后返回 if (content === &apos;&apos; &amp;&amp; !content) &#123; return &apos;&apos; &#125; let str = content str = str.replace(/&lt;xml&gt;[\\s\\S]*?&lt;\\/xml&gt;/ig, &apos;&apos;) str = str.replace(/&lt;style&gt;[\\s\\S]*?&lt;\\/style&gt;/ig, &apos;&apos;) str = str.replace(/&lt;\\/?[^&gt;]*&gt;/g, &apos;&apos;) str = str.replace(/[ | ]*\\n/g, &apos;\\n&apos;) str = str.replace(/&amp;nbsp;/ig, &apos;&apos;) return str &#125; this.editor.customConfig.uploadImgMaxLength = 5 // 限制一次最多上传图片个数 this.editor.customConfig.uploadImgShowBase64 = true // 允许上传本地图片，转为bash64或如下接口上传 this.editor.customConfig.uploadImgServer = &apos;http://192.168.20.56:8089/uploadImg&apos; // 你的上传图片的接口 this.editor.customConfig.uploadFileName = &apos;newsImages&apos; // 你自定义的文件名，默认名字 this.editor.customConfig.uploadImgTimeout = 6000000 // 超时时间 this.editor.customConfig.menus = [ // 菜单配置 &apos;head&apos;, // 标题 &apos;bold&apos;, // 粗体 &apos;fontSize&apos;, // 字号 // &apos;fontName&apos;, // 字体 &apos;italic&apos;, // 斜体 &apos;underline&apos;, // 下划线 &apos;strikeThrough&apos;, // 删除线 &apos;foreColor&apos;, // 文字颜色 // &apos;backColor&apos;, // 背景颜色 &apos;link&apos;, // 插入链接 &apos;list&apos;, // 列表 &apos;justify&apos;, // 对齐方式 // &apos;quote&apos;, // 引用 // &apos;emoticon&apos;, // 表情 &apos;image&apos;, // 插入图片 &apos;table&apos;, // 表格 // &apos;code&apos;, // 插入代码 &apos;undo&apos;, // 撤销 &apos;redo&apos; // 重复 ] // 下面是最重要的的方法 this.editor.customConfig.uploadImgHooks = &#123; before: function (xhr, editor, files) &#123; // 图片上传之前触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象，files 是选择的图片文件 console.log(files) // 如果返回的结果是 &#123;prevent: true, msg: &apos;xxxx&apos;&#125; 则表示用户放弃上传 // return &#123; // prevent: true, // msg: &apos;放弃上传&apos; // &#125; &#125;, success: function (xhr, editor, result) &#123; // 图片上传并返回结果，图片插入成功之后触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象，result 是服务器端返回的结果 console.log(result) this.imgUrl = result.pathmap &#125;, fail: function (xhr, editor, result) &#123; // 图片上传并返回结果，但图片插入错误时触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象，result 是服务器端返回的结果 &#125;, error: function (xhr, editor) &#123; // 图片上传出错时触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象 &#125;, timeout: function (xhr, editor) &#123; // 图片上传超时时触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象 &#125;, // 如果服务器端返回的不是 &#123;errno:0, data: [...]&#125; 这种格式，可使用该配置 // （但是，服务器端返回的必须是一个 JSON 格式字符串！！！否则会报错） customInsert: function (insertImg, result, editor) &#123; // 图片上传并返回结果，自定义插入图片的事件（而不是编辑器自动插入图片！！！） // insertImg 是插入图片的函数，editor 是编辑器对象，result 是服务器端返回的结果 // result 必须是一个 JSON 格式字符串！！！否则报错 // 举例：假如上传图片成功后，服务器端返回的是 &#123;url:&apos;....&apos;&#125; 这种格式，即可这样插入图片： // let url = Object.values(result.path) // result.data就是服务器返回的图片名字和链接 // JSON.stringify(url) // 在这里转成JSON格式 let url = result.pathmap let len = url.length for (let i = 0; i &lt; len; i++) &#123; insertImg(url[i].path) &#125; &#125; &#125; this.editor.create() // 创建富文本实例 &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#wangeditor &#123; width: 600px;&#125;&lt;/style&gt; 页面使用 12345678&lt;wang-editor :catchData=&quot;catchData&quot; :content=&quot;form.newsContent&quot;&gt;&lt;/wang-editor&gt; methods: &#123; catchData (value) &#123; console.log(value) this.content = value // 在这里接受子组件传过来的参数，赋值给data里的参数 &#125;,&#125; vue-amapvue2调用高德地图(Amap)及其UI组件 部署Vue项目打包部署到apache服务器 后端foldername项目 router index.js 1base: &apos;/foldername/&apos;, config index.js 1assetsPublicPath: &apos;/foldername/&apos; foldername项目下新建.htaccess","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"mui的一些实战","slug":"live/study-mui","date":"2019-08-19T06:54:46.000Z","updated":"2019-08-19T09:30:57.585Z","comments":true,"path":"2019/08/19/live/study-mui/","link":"","permalink":"http://yoursite.com/2019/08/19/live/study-mui/","excerpt":"","text":"最近在用mui做一款app,在此总结遇见的问题 解决方案所用工具: HBuilderX H5+App 底部选项卡模板 底部选项卡util.js创建成功后js文件夹下有util.js文件 12345678910111213141516171819202122232425262728293031323334//util.jsvar util = &#123; options: &#123; &lt;!-- 选项卡被选中的颜色 --&gt; ACTIVE_COLOR: &quot;#007aff&quot;, &lt;!-- 选项卡未被选中的颜色 --&gt; NORMAL_COLOR: &quot;#000&quot;, &lt;!-- 选项卡对应的页面 --&gt; subpages: [&quot;html/tab-webview-subpage-chat.html&quot;, &quot;html/tab-webview-subpage-contact.html&quot;] &#125;, ... initSubpage: function(aniShow) &#123; var subpage_style = &#123; top: 0, &lt;!-- 底部选项卡高度，建议改为50，51会页面穿透 --&gt; bottom: 51 &#125;, subpages = util.options.subpages, self = plus.webview.currentWebview(), temp = &#123;&#125;; ... toggleNview: function(currIndex) &#123; currIndex = currIndex * 2; // 重绘当前tag 包括icon和text，所以执行两个重绘操作 util.updateSubNView(currIndex, util.options.ACTIVE_COLOR); util.updateSubNView(currIndex + 1, util.options.ACTIVE_COLOR); // 重绘兄弟tag 反之排除当前点击的icon和text &lt;!-- 默认底部选项卡是4个选项，于是为8，若选项卡数目变化，相应i最大值也要修改 --&gt; for(var i = 0; i &lt; 8; i++) &#123; if(i !== currIndex &amp;&amp; i !== currIndex + 1) &#123; util.updateSubNView(i, util.options.NORMAL_COLOR); &#125; &#125; &#125;, manifest.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// manifest.json&quot;plus&quot;: &#123; &quot;launchwebview&quot;: &#123; &quot;bottom&quot;: &quot;0px&quot;, &lt;!-- 底部选项卡背景颜色 --&gt; &quot;background&quot;: &quot;#fff&quot;, &quot;subNViews&quot;: [ &#123; &quot;id&quot;: &quot;tabBar&quot;, &quot;styles&quot;: &#123; &quot;bottom&quot;: &quot;0px&quot;, &quot;left&quot;: &quot;0&quot;, &quot;height&quot;: &quot;50px&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;backgroundColor&quot;: &quot;#fff&quot; &#125;, &quot;tags&quot;: [ &#123; &quot;tag&quot;: &quot;font&quot;, &quot;id&quot;: &quot;indexIcon&quot;, &lt;!-- text放图标，图标可在官网查，然后再mui.css中查找对应的字符，替换掉\\u后的字符 --&gt; &quot;text&quot;: &quot;\\ue500&quot;, &quot;position&quot;: &#123; &quot;top&quot;: &quot;4px&quot;, &quot;left&quot;: &quot;0&quot;, &lt;!-- 25%是四个选项卡 --&gt; &quot;width&quot;: &quot;25%&quot;, &quot;height&quot;: &quot;24px&quot; &#125;, &quot;textStyles&quot;: &#123; &quot;fontSrc&quot;: &quot;_www/fonts/mui.ttf&quot;, &quot;align&quot;: &quot;center&quot;, &quot;size&quot;: &quot;24px&quot; &#125;, &#123; &quot;tag&quot;: &quot;font&quot;, &quot;id&quot;: &quot;indexText&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;position&quot;: &#123; &quot;top&quot;: &quot;23px&quot;, &quot;left&quot;: &quot;0&quot;, &quot;width&quot;: &quot;25%&quot;, &quot;height&quot;: &quot;24px&quot; &#125;, &quot;textStyles&quot;: &#123; &quot;align&quot;: &quot;center&quot;, &quot;size&quot;: &quot;10px&quot; &#125; &#125;, 弹出框1234567&lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;!-- href锚点 点击显示弹出框 --&gt; &lt;a class=&quot;mui-navigate-right&quot; href=&quot;#namePopover&quot;&gt; 昵称 &lt;span class=&quot;mui-pull-right gray-big mr20&quot;&gt;一个测试的账号&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 1234567891011121314&lt;!-- 弹出框内容 --&gt;&lt;div id=&quot;namePopover&quot; class=&quot;mui-popover&quot;&gt; &lt;div class=&quot;mui-popover-arrow mui-hidden&quot;&gt;&lt;/div&gt; &lt;form class=&quot;mui-input-group input-group&quot;&gt; &lt;label class=&quot;dark-big&quot;&gt;昵称编辑&lt;/label&gt; &lt;div class=&quot;mui-input-row&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;mui-input-clear gray-big&quot; placeholder=&quot;请输入新昵称&quot; value=&quot;一个测试的账号&quot; autofocus=&quot;autofocus&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;mui-button-row&quot; style=&quot;text-align: right;margin-top: 10px;&quot;&gt; &lt;a href=&quot;&quot; class=&quot;green-big cancel&quot;&gt;取消&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;green-big confirm&quot;&gt;确认&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 图片浏览需要mui.css, mui.js, mui.previewimage.css, mui.previewimage.js其中mui.previewimage.css是从mui样例imageviewer.html文件的style中复制成的单独css文件 123&lt;img src=&quot;login.jpg&quot; id=&quot;head-img&quot; data-preview-src=&quot;&quot; data-preview-group=&quot;1&quot; /&gt;mui.previewImage(); //图片预览 图片裁剪","categories":[{"name":"mui","slug":"mui","permalink":"http://yoursite.com/categories/mui/"}],"tags":[{"name":"mui","slug":"mui","permalink":"http://yoursite.com/tags/mui/"}]},{"title":"ECMAScript中引用类型","slug":"live/JObject","date":"2019-07-15T08:34:56.000Z","updated":"2019-08-19T06:52:26.910Z","comments":true,"path":"2019/07/15/live/JObject/","link":"","permalink":"http://yoursite.com/2019/07/15/live/JObject/","excerpt":"","text":"基本类型值是按值访问的：基本数据类型，为Null，Undefined，Number，Boolean，String，Symbol。值保存在栈内存中。引用类型值是按引用访问的：复杂数据类型，为Object。一切皆是对象。可以添加属性和方法，也可以改变和删除其属性和方法。值保存在堆内存中。 Array基本类型值是按值访问的：基本数据类型，为Null，Undefined，Number，Boolean，String，Symbol。值保存在栈内存中。 引用类型值是按引用访问的：复杂数据类型，为Object。一切皆是对象。可以添加属性和方法，也可以改变和删除其属性和方法。值保存在堆内存中。 转换方法 toLocaleString() toString() valueOf() join() 数组元素用某个字符连接成字符串 栈方法 push() 在数组最后增加元素，可多参 pop() 删除数组最后面一个元素，无参 队列方法 shift() 删除数组最前面一个元素，无参 unshift() 在数组前面增加元素，可多参 重排序方法 返回值是经过排序之后的数组。 reverse() 反转 sort() 排序 操作方法 concat() 把当前数组与另一个数组连接起来 返回新数组 slice() 截取数组索引区域[l,r) 返回新数组 splice() 增/删数组中元素 arr.splice(index,howmany,item1…itemX) 删除从 index 处开始的零个或多个元素， 并且用参数列表中声明的一个或多个值来替换那些被删除的元素。 规定增删项目的位置，要删除的项目数量，向数组添加的新项目 arr为最后结果，arr.splice(…)为删除的结果 位置方法 indexOf() 从后往前搜索指定元素的索引号 lastIndexOf() 从后往前搜索指定元素的索引号 迭代方法 对数组中的每一项运行给定函数。 every() 对数组中的每一项运行给定函数。每一项返回true，就返回true some() 对数组中的每一项运行给定函数。任一项返回true，就返回true filter() 对数组中的每一项运行给定函数。返回true的项组成的数组 forEach() 对数组中的每一项运行给定函数。无返回值 map() 对数组中的每一项运行给定函数。返回每次函数调用的结果组成的数组 12function(item,index,arr)&#123;&#125;// item 当前元素值（必选），index当前元素索引，arr此数组 归并方法 reduce() reduceRight()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue学习笔记三：Render函数","slug":"live/study-vue2","date":"2019-07-10T09:37:48.000Z","updated":"2019-07-24T02:22:44.057Z","comments":true,"path":"2019/07/10/live/study-vue2/","link":"","permalink":"http://yoursite.com/2019/07/10/live/study-vue2/","excerpt":"","text":"Render函数渲染函数 虚拟DOM Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM，提升渲染性能。 Render函数用于实现虚拟DOM Virtual Dom是一个轻量级的JavaScript对象，状态变化时进行Diff算法 Virtual Dom基于JavaScript计算 “虚拟节点 (virtual node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。 123render: function (createElement) &#123; return createElement(&apos;h1&apos;, this.blogTitle)&#125; createElementRender函数通过createElement参数来创建Virtual Dom 参数一必选，HTML标签、组件或函数 {String | Object | Function} 参数二可选，对应属性的数据对象 {Object} 参数三可选，子节点 {String | Array}","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue学习笔记二：组件、自定义指令","slug":"live/study_vue1","date":"2019-07-06T09:58:01.000Z","updated":"2019-07-11T09:06:42.171Z","comments":true,"path":"2019/07/06/live/study_vue1/","link":"","permalink":"http://yoursite.com/2019/07/06/live/study_vue1/","excerpt":"","text":"组件 component 组件名推荐使用小写加减号分割形式命名 组件注册必须在Vue实例申明之前 每个组件必须只有一个根元素 123Vue.component(&apos;my-component&apos;,&#123; // 选项&#125;); 局部注册组件使用components选项。只在实例作用域下有效。123456let vm = new Vue(&#123; el:&apos;#vm&apos;, components:&#123; template:&apos;&apos; &#125;&#125;); 选项 name选项，可用来递归 data选项，必须是函数，返回对象数据 computed methods props选项，声明需要从父级接收的数据 父组件向子组件传数据 值为字符串数组或对象 驼峰命名的props名称，DOM上改为短横分隔命名 值为对象时，k为名称，v为类型 v-bind动态绑定props值 父子通信props 在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是两种，一种是字符串数组，一种是对象。 props中声明的数据与组件data函数return的数据的主要区别就是props的来自父级，而data中的是组件自己的数据，作用域是组件本身，这两种数据都可以在模板template及计算属性computed和方法methods中使用。 由于HTML特性不区分大小写，当使用DOM模板时，驼峰命名（）的props名称要转为短横分割命名（kebab-case）。 1234567&lt;div id=&quot;vm&quot;&gt; &lt;huahua say=&quot;hello&quot;&gt;&lt;/huahua&gt;&lt;/div&gt;Vue.component(&apos;huahua&apos;,&#123; props:[&apos;say&apos;], template:`&lt;div&gt;huahua:&#123;&#123;say&#125;&#125;&lt;/div&gt;`,&#125;); 子父通信.$emit(自定义的事件名,携带的数据).$on(自定义的事件名,回调函数) 子组件用$emit()来触发事件，父组件用$on()来监听子组件的事件。 12345678910111213141516171819202122232425&lt;div id=&quot;vm&quot;&gt; &lt;for-show @show=&quot;show_num&quot;&gt;&lt;/for-show&gt; &lt;p v-if=&quot;iftrue&quot;&gt;余额：55元&lt;/p&gt;&lt;/div&gt;Vue.component(&apos;for-show&apos;,&#123; template:`&lt;div&gt;&lt;button @click=&quot;on_click&quot;&gt;显示余额&lt;/button&gt;&lt;/div&gt;`, methods:&#123; on_click:function () &#123; this.$emit(&apos;show&apos;,&#123;a:2&#125;) &#125; &#125;&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;, data:&#123; iftrue:false &#125;, methods:&#123; show_num:function (data) &#123; console.log(data); this.iftrue = true; &#125; &#125;&#125;); 非父子通信父子、兄弟、跨级通信 创建一个空的Vue实例，作为中央事件总线bus 全局定义组件 创建Vue实例，在mounted钩子函数里监听来自bus的事件 12345678910111213141516171819202122232425262728293031323334// 例子1&lt;div id=&quot;vm&quot;&gt; &lt;comp-txt&gt;&lt;/comp-txt&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;let bus = new Vue();Vue.component(&apos;comp-txt&apos;,&#123; template:`&lt;div&gt; &lt;button @click=&quot;on_click&quot; &gt;传递事件&lt;/button&gt; &lt;/div&gt;`, methods:&#123; on_click: function () &#123; bus.$emit(&apos;on_message&apos;,this.txt); &#125; &#125;, data: function () &#123; return &#123; txt:&apos;hello world&apos; &#125; &#125;&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;, data:&#123; message:&apos;&apos; &#125;, mounted: function () &#123; let _this = this; bus.$on(&apos;on_message&apos;,function(msg)&#123; _this.message=msg; &#125;) &#125;&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142// 例子2&lt;div id=&quot;vm&quot;&gt; &lt;say&gt;&lt;/say&gt; &lt;saied&gt;&lt;/saied&gt;&lt;/div&gt; let bus = new Vue();Vue.component(&apos;say&apos;,&#123; template:`&lt;div&gt; 他在说:&lt;input type=&quot;text&quot; @keyup=&quot;saying&quot; v-model=&quot;he_say&quot; /&gt; &lt;/div&gt;`, methods:&#123; saying:function () &#123; bus.$emit(&apos;say_what&apos;,this.he_say); &#125; &#125;, data: function () &#123; return &#123; he_say:&apos;&apos; &#125; &#125;&#125;);Vue.component(&apos;saied&apos;,&#123; template:`&lt;div&gt; 他说了:&#123;&#123;msg&#125;&#125; &lt;/div&gt;`, data: function () &#123; return &#123; msg:&apos;&apos; &#125; &#125;, mounted:function () &#123; let _this = this; bus.$on(&apos;say_what&apos;,function (data) &#123; // this指向bus _this.msg = data; &#125;) &#125;&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;&#125;); 插槽内容分发，用到slot Vue组件3个API来源：props传递数据、events触发事件、slot内容分发 插槽内可以包含任何模板代码，包括 HTML 插槽内也可以包含其它的组件 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 12345678910&lt;div id=&quot;vm&quot;&gt; &lt;comp-txt&gt;&lt;p&gt;父组件的内容&lt;/p&gt;&lt;/comp-txt&gt;&lt;/div&gt;Vue.component(&apos;comp-txt&apos;,&#123; template:`&lt;div&gt;&lt;slot&gt;&lt;p&gt;父组件没有内容&lt;/p&gt;&lt;/slot&gt;&lt;/div&gt;`&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;,&#125;); 具名插槽 元素有一个特殊的特性：name。这个特性可以用来定义额外的插槽。 在向具名插槽提供内容的时候，可以在一个 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称。 v-slot: 有参数时可缩写为 # 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;vm&quot;&gt; &lt;comp-child&gt; &lt;template #header&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;/template&gt; &lt;!-- &lt;h2 slot=&quot;header&quot;&gt;标题&lt;/h2&gt; --&gt; &lt;p&gt;正文&lt;/p&gt; &lt;p&gt;还是正文&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;底部&lt;/p&gt; &lt;/template&gt; &lt;!-- &lt;p slot=&quot;footer&quot;&gt;底部&lt;/p&gt; --&gt; &lt;/comp-child&gt;&lt;/div&gt; Vue.component(&apos;comp-child&apos;, &#123; template: `&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;`&#125;);let vm = new Vue(&#123; el: &apos;#vm&apos;,&#125;); 作用域插槽绑定在 元素上的特性被称为插槽 prop。现在在父级作用域中，我们可以给 v-slot 带一个值来定义我们提供的插槽 prop 的名字 12345678910111213141516171819202122232425262728&lt;div id=&quot;vm&quot;&gt; &lt;comp-child&gt; &lt;template v-slot:header=&quot;demo&quot;&gt; &lt;h1&gt;标题&lt;span&gt;&#123;&#123;demo.msg&#125;&#125;&lt;/span&gt;&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;正文&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;底部&lt;/p&gt; &lt;/template&gt; &lt;/comp-child&gt;&lt;/div&gt; Vue.component(&apos;comp-child&apos;, &#123; template: `&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot; msg=&quot;副标题&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;`&#125;);let vm = new Vue(&#123; el: &apos;#vm&apos;,&#125;); 动态组件 is特性 元素 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件 Vue 允许以一个工厂函数的方式定义组件，这个工厂函数会异步解析组件定义。Vue只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;) 自定义指令directive 12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;,&#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;); 局部指令 directives选项 12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 钩子函数 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (父节点存在即可调用，不必存在于document中)。 update：被绑定元素插入父节点时调用，而不论绑定值是否变化。通过比较更新前后的值来忽略不必要的模板更新。 componentUpdated：被绑定元素所在模板完成一次更新周期时调用。 unbind：只调用一次，指令与元素解绑时调用。钩子函数参数 el指令所绑定的元素，可以用来直接操作 DOM 。 binding name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：绑定值的字符串形式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数。例如 v-my-directive:foo 中，arg的值为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象modifiers的值为 { foo: true, bar: true }。 vnodeVue 编译生成的虚拟节点。 oldVnode上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 1234567891011121314&lt;div id=&quot;baseexample&quot;&gt; &lt;p&gt;Scroll down the page&lt;/p&gt; &lt;p v-pin=&quot;200&quot;&gt;Stick me 200px from the top of the page&lt;/p&gt;&lt;/div&gt;Vue.directive(&apos;pin&apos;, &#123; bind: function (el, binding, vnode) &#123; el.style.position = &apos;fixed&apos; el.style.top = binding.value + &apos;px&apos; &#125;&#125;)new Vue(&#123; el: &apos;#baseexample&apos;&#125;) 动态参数v-mydirective:[argument]=”value” 1234567891011121314151617181920&lt;div id=&quot;dynamicexample&quot;&gt; &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt; &lt;p v-pin:[direction]=&quot;200&quot;&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt;Vue.directive(&apos;pin&apos;, &#123; bind: function (el, binding, vnode) &#123; el.style.position = &apos;fixed&apos; var s = (binding.arg == &apos;left&apos; ? &apos;left&apos; : &apos;top&apos;) el.style[s] = binding.value + &apos;px&apos; &#125;&#125;)new Vue(&#123; el: &apos;#dynamicexample&apos;, data: function () &#123; return &#123; direction: &apos;left&apos; &#125; &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Git笔记和hexo笔记","slug":"live/study-git","date":"2019-07-03T09:01:25.000Z","updated":"2019-08-31T06:48:01.495Z","comments":true,"path":"2019/07/03/live/study-git/","link":"","permalink":"http://yoursite.com/2019/07/03/live/study-git/","excerpt":"","text":"git常用命令只有几个，但由于不常使用，基本记不住，于是便总结为一个笔记，用时就打开复制一下。之前我只是将git当代码仓库使用。昨天制作了基于hexo的git博客，今天又换了电脑。于是将所用命令再次整理下。 目前我使用的命令步骤 hexo new 文件名 git add . git commit -m “some descrption” git push origin hexo hexo g -d 来源于最底下链接内容： 123456789迁移工作已完成，在两台电脑之间的同步操作如下：git pull从远程hexo分支拉取最新的环境文件到本地，可以理解为svn的更新操作。比如在公司写了博客，回家在电脑上也要写需要先执行这一步操作。文章写完，要发布时，需要先提交环境文件，再发布文章。按以下顺序执行命令：git add .、git commit -m &quot;some descrption&quot;、git push origin hexo、hexo g -d。作者：nikolausliu链接：https://www.jianshu.com/p/fceaf373d797/ git使用拉项目到本地 1git clone 远程仓库地址 初次创建仓库： 1234561. 在网上创建一个仓库，git clone 仓库地址2. 把项目复制进仓库名一样的文件夹内，cd 仓库名文件夹3. 将文件加入暂存区，git add . 4. 暂存区内容提交到仓库，git commit -m &quot;注释内容&quot;5. 把本地仓库的项目推送到github上，git push -u origin master // 第一次上传成功后可以去掉-u 仓库里已有文件再提交： 1234561. cd 仓库名文件夹2. 将文件加入暂存区，git add . 3. 暂存区内容提交到仓库，git commit -m &quot;注释内容&quot;4. 获取远程库与本地同步合并，git pull --rebase origin master5. 把本地库内容推送到远程库上，git push -u origin master //第一次上传成功后可以去掉-u 其他常用命令（git bash用的是linux的命令） 123初始化仓库：npm init新建文件夹：mkdir 文件夹名新建文件：touch 文件名 hexo使用新建文件1hexo new 文件名 编写完后1231. hexo clean 清除缓存文件2. hexo g 生成文件3. hexo d 推送到远端github仓库 hexo博客同步管理及迁移。由于换成台式电脑，hexo迁移遇到一些问题，根据此链接慢慢解决了。 Git和Github Git是版本控制系统 Github是在线的基于Git的代码托管服务。 NPM全称Node Package Manager，Node.js的包管理工具 其他github作为图床 将网址中blob改为raw,就是图片外链地址","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Vue学习笔记一：内置指令、选项等","slug":"live/study-vue","date":"2019-07-02T07:16:29.000Z","updated":"2019-07-12T02:05:14.265Z","comments":true,"path":"2019/07/02/live/study-vue/","link":"","permalink":"http://yoursite.com/2019/07/02/live/study-vue/","excerpt":"1. 初识Vue.js高级功能 解耦视图与数据 可复用的组件 前端路由 状态管理 虚拟DOM","text":"1. 初识Vue.js高级功能 解耦视图与数据 可复用的组件 前端路由 状态管理 虚拟DOM MVVM模式 Model-View-ViewModel 视图-模型-视图模型 2. 数据绑定 v-model el data filters 过滤器 v-pre 跳过编译生命周期钩子 created 实例创建完成后调用 mounted el挂到实例上后调用 beforeDestroy 实例销毁之前调用。主要用于解绑监听事件插值与表达式 Mustache语法 也可使用简单的JavaScript表达式指令 指令Directives，前缀v，当表达式的值 当其表达式的值改变时，相应地将某些行为应用到DOM上 v-bind 动态更新HTML元素上的属性 v-on 绑定事件监听器 methods语法糖 v-bind简写为 : v-on简写 为@ 3. 计算属性 以函数形式写在Vue实例内的computed选项内，最终返回计算后的结果 每一个计算属性都包含一个getter和一个setter getter 默认，用于读取 setter 写入时触发 computed依赖缓存，数据变化时才会重新取值 methods重新渲染时就会被调用 4. 指令 :class设置一个对象，动态切换class 表达式每项为真时，对应类名就会加载 表达式过长或逻辑复杂时可绑定计算属性 :class绑定一个数组，应用一个class列表 可以在数组语法中使用对象语法 v-cloak 在Vue实例结束编译时从绑定的HTML上移除 v-once 只渲染一次，之后不再随数据的变化重新渲染 v-if v-else-if v-else v-else-if要紧跟着v-if v-else要紧跟着v-else-if或v-if v-show 简单的CSS属性切换 表达式值为false时，元素会隐藏 v-show不能在上使用 v-for 表达式结合in使用 遍历数组时，支持一个可选参数作为索引 遍历对象时，支持两个可选参数 键名 索引 push,pop,shift,unshift,splice,sort,reverse filter,concat,slice 修饰符：stop 阻止事件冒泡 prevent capture self once 按键修饰符：enter tab delete esc 5. 表单与v-model v-model 表单类元素的双向绑定数据v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。 v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]}]}