{"meta":{"title":"FeiYangbuMian","subtitle":null,"description":null,"author":"FeiYangbuMian","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Vue学习笔记 二","slug":"live/study_vue1","date":"2019-07-06T09:58:01.000Z","updated":"2019-07-09T03:12:11.545Z","comments":true,"path":"2019/07/06/live/study_vue1/","link":"","permalink":"http://yoursite.com/2019/07/06/live/study_vue1/","excerpt":"","text":"组件 component 组件名推荐使用小写加减号分割形式命名 组件注册必须在Vue实例申明之前 每个组件必须只有一个根元素 123Vue.component(&apos;my-component&apos;,&#123; // 选项&#125;); 局部注册组件使用components选项。只在实例作用域下有效。 123456let vm = new Vue(&#123; el:&apos;#vm&apos;, components:&#123; template:&apos;&apos; &#125;&#125;); 选项 name选项，可用来递归 data选项，必须是函数，返回对象数据 computed methods props选项，声明需要从父级接收的数据 父组件向子组件传数据 值为字符串数组或对象 驼峰命名的props名称，DOM上改为短横分隔命名 值为对象时，k为名称，v为类型 v-bind动态绑定props值 父子通信props 在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是两种，一种是字符串数组，一种是对象。 props中声明的数据与组件data函数return的数据的主要区别就是props的来自父级，而data中的是组件自己的数据，作用域是组件本身，这两种数据都可以在模板template及计算属性computed和方法methods中使用。 由于HTML特性不区分大小写，当使用DOM模板时，驼峰命名（）的props名称要转为短横分割命名（kebab-case）。 1234567&lt;div id=&quot;vm&quot;&gt; &lt;huahua say=&quot;hello&quot;&gt;&lt;/huahua&gt;&lt;/div&gt;Vue.component(&apos;huahua&apos;,&#123; props:[&apos;say&apos;], template:`&lt;div&gt;huahua:&#123;&#123;say&#125;&#125;&lt;/div&gt;`,&#125;); 子父通信.$emit(自定义的事件名,携带的数据).$on(自定义的事件名,回调函数) 子组件用$emit()来触发事件，父组件用$on()来监听子组件的事件。 12345678910111213141516171819202122232425&lt;div id=&quot;vm&quot;&gt; &lt;for-show @show=&quot;show_num&quot;&gt;&lt;/for-show&gt; &lt;p v-if=&quot;iftrue&quot;&gt;余额：55元&lt;/p&gt;&lt;/div&gt;Vue.component(&apos;for-show&apos;,&#123; template:`&lt;div&gt;&lt;button @click=&quot;on_click&quot;&gt;显示余额&lt;/button&gt;&lt;/div&gt;`, methods:&#123; on_click:function () &#123; this.$emit(&apos;show&apos;,&#123;a:2&#125;) &#125; &#125;&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;, data:&#123; iftrue:false &#125;, methods:&#123; show_num:function (data) &#123; console.log(data); this.iftrue = true; &#125; &#125;&#125;); 非父子通信父子、兄弟、跨级通信 创建一个空的Vue实例，作为中央事件总线bus 全局定义组件 创建Vue实例，在mounted钩子函数里监听来自bus的事件 12345678910111213141516171819202122232425262728293031323334// 例子1&lt;div id=&quot;vm&quot;&gt; &lt;comp-txt&gt;&lt;/comp-txt&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;let bus = new Vue();Vue.component(&apos;comp-txt&apos;,&#123; template:`&lt;div&gt; &lt;button @click=&quot;on_click&quot; &gt;传递事件&lt;/button&gt; &lt;/div&gt;`, methods:&#123; on_click: function () &#123; bus.$emit(&apos;on_message&apos;,this.txt); &#125; &#125;, data: function () &#123; return &#123; txt:&apos;hello world&apos; &#125; &#125;&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;, data:&#123; message:&apos;&apos; &#125;, mounted: function () &#123; let _this = this; bus.$on(&apos;on_message&apos;,function(msg)&#123; _this.message=msg; &#125;) &#125;&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142// 例子2&lt;div id=&quot;vm&quot;&gt; &lt;say&gt;&lt;/say&gt; &lt;saied&gt;&lt;/saied&gt;&lt;/div&gt; let bus = new Vue();Vue.component(&apos;say&apos;,&#123; template:`&lt;div&gt; 他在说:&lt;input type=&quot;text&quot; @keyup=&quot;saying&quot; v-model=&quot;he_say&quot; /&gt; &lt;/div&gt;`, methods:&#123; saying:function () &#123; bus.$emit(&apos;say_what&apos;,this.he_say); &#125; &#125;, data: function () &#123; return &#123; he_say:&apos;&apos; &#125; &#125;&#125;);Vue.component(&apos;saied&apos;,&#123; template:`&lt;div&gt; 他说了:&#123;&#123;msg&#125;&#125; &lt;/div&gt;`, data: function () &#123; return &#123; msg:&apos;&apos; &#125; &#125;, mounted:function () &#123; let _this = this; bus.$on(&apos;say_what&apos;,function (data) &#123; // this指向bus _this.msg = data; &#125;) &#125;&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;&#125;); 插槽内容分发，用到slot Vue组件3个API来源：props传递数据、events触发事件、slot内容分发 插槽内可以包含任何模板代码，包括 HTML 插槽内也可以包含其它的组件 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 12345678910&lt;div id=&quot;vm&quot;&gt; &lt;comp-txt&gt;&lt;p&gt;父组件的内容&lt;/p&gt;&lt;/comp-txt&gt;&lt;/div&gt;Vue.component(&apos;comp-txt&apos;,&#123; template:`&lt;div&gt;&lt;slot&gt;&lt;p&gt;父组件没有内容&lt;/p&gt;&lt;/slot&gt;&lt;/div&gt;`&#125;);let vm = new Vue(&#123; el:&apos;#vm&apos;,&#125;); 具名插槽 元素有一个特殊的特性：name。这个特性可以用来定义额外的插槽。 在向具名插槽提供内容的时候，可以在一个 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称。 有参数时可缩写为 ```#```1234567891011121314151617181920212223242526272829303132```&lt;div id=&quot;vm&quot;&gt; &lt;comp-child&gt; &lt;template #header&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;/template&gt; &lt;!-- &lt;h2 slot=&quot;header&quot;&gt;标题&lt;/h2&gt; --&gt; &lt;p&gt;正文&lt;/p&gt; &lt;p&gt;还是正文&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;底部&lt;/p&gt; &lt;/template&gt; &lt;!-- &lt;p slot=&quot;footer&quot;&gt;底部&lt;/p&gt; --&gt; &lt;/comp-child&gt;&lt;/div&gt; Vue.component(&apos;comp-child&apos;, &#123; template: `&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;`&#125;);let vm = new Vue(&#123; el: &apos;#vm&apos;,&#125;); 作用域插槽绑定在 元素上的特性被称为插槽 prop。现在在父级作用域中，我们可以给 v-slot 带一个值来定义我们提供的插槽 prop 的名字 12345678910111213141516171819202122232425262728&lt;div id=&quot;vm&quot;&gt; &lt;comp-child&gt; &lt;template v-slot:header=&quot;demo&quot;&gt; &lt;h1&gt;标题&lt;span&gt;&#123;&#123;demo.msg&#125;&#125;&lt;/span&gt;&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;正文&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;底部&lt;/p&gt; &lt;/template&gt; &lt;/comp-child&gt;&lt;/div&gt; Vue.component(&apos;comp-child&apos;, &#123; template: `&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot; msg=&quot;副标题&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;`&#125;);let vm = new Vue(&#123; el: &apos;#vm&apos;,&#125;); 动态组件 is特性 元素 要求被切换到的组件都有自己的名字，不论是通过组件的 name 选项还是局部/全局注册。1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件 Vue 允许以一个工厂函数的方式定义组件，这个工厂函数会异步解析组件定义。Vue只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Git笔记和hexo笔记","slug":"live/study-git","date":"2019-07-03T09:01:25.000Z","updated":"2019-07-06T09:56:17.735Z","comments":true,"path":"2019/07/03/live/study-git/","link":"","permalink":"http://yoursite.com/2019/07/03/live/study-git/","excerpt":"","text":"git常用命令只有几个，但由于不常使用，基本记不住，于是便总结为一个笔记，用时就打开复制一下。之前我只是将git当代码仓库使用。昨天制作了基于hexo的git博客，今天又换了电脑。于是将所用命令再次整理下。 目前我使用的命令步骤 git add . git commit -m “some descrption” git push origin hexo hexo g -d 来源于最底下链接内容： 123456789迁移工作已完成，在两台电脑之间的同步操作如下：git pull从远程hexo分支拉取最新的环境文件到本地，可以理解为svn的更新操作。比如在公司写了博客，回家在电脑上也要写需要先执行这一步操作。文章写完，要发布时，需要先提交环境文件，再发布文章。按以下顺序执行命令：git add .、git commit -m &quot;some descrption&quot;、git push origin hexo、hexo g -d。作者：nikolausliu链接：https://www.jianshu.com/p/fceaf373d797/ git使用拉项目到本地 1git clone 远程仓库地址 初次创建仓库： 1234561. 在网上创建一个仓库，git clone 仓库地址2. 把项目复制进仓库名一样的文件夹内，cd 仓库名文件夹3. 将文件加入暂存区，git add . 4. 暂存区内容提交到仓库，git commit -m &quot;注释内容&quot;5. 把本地仓库的项目推送到github上，git push -u origin master // 第一次上传成功后可以去掉-u 仓库里已有文件再提交： 1234561. cd 仓库名文件夹2. 将文件加入暂存区，git add . 3. 暂存区内容提交到仓库，git commit -m &quot;注释内容&quot;4. 获取远程库与本地同步合并，git pull --rebase origin master5. 把本地库内容推送到远程库上，git push -u origin master //第一次上传成功后可以去掉-u hexo使用新建文件1hexo new 文件名 编写完后1231. hexo clean 清除缓存文件2. hexo g 生成文件3. hexo d 推送到远端github仓库 hexo博客同步管理及迁移。由于换成台式电脑，hexo迁移遇到一些问题，根据此链接慢慢解决了。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Vue学习笔记 一","slug":"live/study-vue","date":"2019-07-02T07:16:29.000Z","updated":"2019-07-03T03:33:00.936Z","comments":true,"path":"2019/07/02/live/study-vue/","link":"","permalink":"http://yoursite.com/2019/07/02/live/study-vue/","excerpt":"1. 初识Vue.js高级功能 解耦视图与数据 可复用的组件 前端路由 状态管理 虚拟DOM","text":"1. 初识Vue.js高级功能 解耦视图与数据 可复用的组件 前端路由 状态管理 虚拟DOM MVVM模式 Model-View-ViewModel 视图-模型-视图模型 2. 数据绑定 v-model el data filters 过滤器 v-pre 跳过编译生命周期钩子 created 实例创建完成后调用 mounted el挂到实例上后调用 beforeDestroy 实例销毁之前调用。主要用于解绑监听事件插值与表达式 Mustache语法 也可使用简单的JavaScript表达式指令 指令Directives，前缀v，当表达式的值 当其表达式的值改变时，相应地将某些行为应用到DOM上 v-bind 动态更新HTML元素上的属性 v-on 绑定事件监听器 methods语法糖 v-bind简写为 : v-on简写 为@ 3. 计算属性 以函数形式写在Vue实例内的computed选项内，最终返回计算后的结果 每一个计算属性都包含一个getter和一个setter getter 默认，用于读取 setter 写入时触发 computed依赖缓存，数据变化时才会重新取值 methods重新渲染时就会被调用 4. 指令 :class设置一个对象，动态切换class 表达式每项为真时，对应类名就会加载 表达式过长或逻辑复杂时可绑定计算属性 :class绑定一个数组，应用一个class列表 可以在数组语法中使用对象语法 v-cloak 在Vue实例结束编译时从绑定的HTML上移除 v-once 只渲染一次，之后不再随数据的变化重新渲染 v-if v-else-if v-else v-else-if要紧跟着v-if v-else要紧跟着v-else-if或v-if v-show 简单的CSS属性切换 表达式值为false时，元素会隐藏 v-show不能在上使用 v-for 表达式结合in使用 遍历数组时，支持一个可选参数作为索引 遍历对象时，支持两个可选参数 键名 索引 push,pop,shift,unshift,splice,sort,reverse filter,concat,slice 修饰符：stop 阻止事件冒泡 prevent capture self once 按键修饰符：enter tab delete esc 5. 表单与v-model v-model 表单类元素的双向绑定数据v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。 v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]}]}